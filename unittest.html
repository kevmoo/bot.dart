        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>unittest Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="styles.css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="favicon.ico">
        
        </head>
        <body data-library="unittest">
        <div class="page">
        <div class="header">
          <a href="index.html"><div class="logo"></div></a>
          <a href="index.html">Dart Documentation</a>
         &rsaquo; <a href="unittest.html">unittest</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
<h2><strong>unittest</strong> library</h2>
<div class="doc"><p>A library for writing dart unit tests.</p>
<p>To import this library, use the pub package manager.
Create a pubspec.yaml file in your project and add
a dependency on unittest with the following lines:</p>
<pre><span class="i ">dependencies</span><span class="p ">:</span>
  <span class="i ">unittest</span><span class="p ">:</span>
    <span class="i ">sdk</span><span class="p ">:</span> <span class="i ">unittest</span></pre>
<p>Then run 'pub install' from your project directory or using
the DartEditor.</p>
<p>Please see <a href="http://pub.dartlang.org/doc">Pub Getting Started</a>
for more details about the pub package manager.</p>
<h2>Concepts</h2><ul><li>
<p>Tests: Tests are specified via the top-level function <a class="crossref" href="unittest.html#test">test</a>, they can be
   organized together using <a class="crossref" href="unittest.html#group">group</a>.</p></li><li>Checks: Test expectations can be specified via <code>expect</code></li><li>Matchers: <code>expect</code> assertions are written declaratively using <code>Matcher</code>s</li><li>
<p>Configuration: The framework can be adapted by calling <a class="crossref" href="unittest.html#configure">configure</a> with a
   <a class="crossref" href="unittest/Configuration.html">Configuration</a>.  Common configurations can be found in this package
   under: 'dom\<em>config.dart' (deprecated), 'html\</em>config.dart' (for running
   tests compiled to Javascript in a browser), and 'vm\_config.dart' (for
   running native Dart tests on the VM).</p></li></ul>
<h2>Examples</h2>
<p>A trivial test:</p>
<pre><span class="k ">import</span> <span class="s si">'package:unittest/unittest.dart'</span><span class="p ">;</span>
<span class="i ">main</span><span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
  <span class="i ">test</span><span class="p ">(</span><span class="s si">'this is a test'</span><span class="p ">,</span> <span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
    <span class="t ">int</span> <span class="i ">x</span> <span class="o ">=</span> <span class="n ">2</span> <span class="o ">+</span> <span class="n ">3</span><span class="p ">;</span>
    <span class="i ">expect</span><span class="p ">(</span><span class="i ">x</span><span class="p ">,</span> <span class="i ">equals</span><span class="p ">(</span><span class="n ">5</span><span class="p ">)</span><span class="p ">)</span><span class="p ">;</span>
  <span class="p ">}</span><span class="p ">)</span><span class="p ">;</span>
<span class="p ">}</span></pre>
<p>Multiple tests:</p>
<pre><span class="k ">import</span> <span class="s si">'package:unittest/unittest.dart'</span><span class="p ">;</span>
<span class="i ">main</span><span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
  <span class="i ">test</span><span class="p ">(</span><span class="s si">'this is a test'</span><span class="p ">,</span> <span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
    <span class="t ">int</span> <span class="i ">x</span> <span class="o ">=</span> <span class="n ">2</span> <span class="o ">+</span> <span class="n ">3</span><span class="p ">;</span>
    <span class="i ">expect</span><span class="p ">(</span><span class="i ">x</span><span class="p ">,</span> <span class="i ">equals</span><span class="p ">(</span><span class="n ">5</span><span class="p ">)</span><span class="p ">)</span><span class="p ">;</span>
  <span class="p ">}</span><span class="p ">)</span><span class="p ">;</span>
  <span class="i ">test</span><span class="p ">(</span><span class="s si">'this is another test'</span><span class="p ">,</span> <span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
    <span class="t ">int</span> <span class="i ">x</span> <span class="o ">=</span> <span class="n ">2</span> <span class="o ">+</span> <span class="n ">3</span><span class="p ">;</span>
    <span class="i ">expect</span><span class="p ">(</span><span class="i ">x</span><span class="p ">,</span> <span class="i ">equals</span><span class="p ">(</span><span class="n ">5</span><span class="p ">)</span><span class="p ">)</span><span class="p ">;</span>
  <span class="p ">}</span><span class="p ">)</span><span class="p ">;</span>
<span class="p ">}</span></pre>
<p>Multiple tests, grouped by category:</p>
<pre><span class="k ">import</span> <span class="s si">'package:unittest/unittest.dart'</span><span class="p ">;</span>
<span class="i ">main</span><span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
  <span class="i ">group</span><span class="p ">(</span><span class="s si">'group A'</span><span class="p ">,</span> <span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
    <span class="i ">test</span><span class="p ">(</span><span class="s si">'test A.1'</span><span class="p ">,</span> <span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
      <span class="t ">int</span> <span class="i ">x</span> <span class="o ">=</span> <span class="n ">2</span> <span class="o ">+</span> <span class="n ">3</span><span class="p ">;</span>
      <span class="i ">expect</span><span class="p ">(</span><span class="i ">x</span><span class="p ">,</span> <span class="i ">equals</span><span class="p ">(</span><span class="n ">5</span><span class="p ">)</span><span class="p ">)</span><span class="p ">;</span>
    <span class="p ">}</span><span class="p ">)</span><span class="p ">;</span>
    <span class="i ">test</span><span class="p ">(</span><span class="s si">'test A.2'</span><span class="p ">,</span> <span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
      <span class="t ">int</span> <span class="i ">x</span> <span class="o ">=</span> <span class="n ">2</span> <span class="o ">+</span> <span class="n ">3</span><span class="p ">;</span>
      <span class="i ">expect</span><span class="p ">(</span><span class="i ">x</span><span class="p ">,</span> <span class="i ">equals</span><span class="p ">(</span><span class="n ">5</span><span class="p ">)</span><span class="p ">)</span><span class="p ">;</span>
    <span class="p ">}</span><span class="p ">)</span><span class="p ">;</span>
  <span class="p ">}</span><span class="p ">)</span><span class="p ">;</span>
  <span class="i ">group</span><span class="p ">(</span><span class="s si">'group B'</span><span class="p ">,</span> <span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
    <span class="i ">test</span><span class="p ">(</span><span class="s si">'this B.1'</span><span class="p ">,</span> <span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
      <span class="t ">int</span> <span class="i ">x</span> <span class="o ">=</span> <span class="n ">2</span> <span class="o ">+</span> <span class="n ">3</span><span class="p ">;</span>
      <span class="i ">expect</span><span class="p ">(</span><span class="i ">x</span><span class="p ">,</span> <span class="i ">equals</span><span class="p ">(</span><span class="n ">5</span><span class="p ">)</span><span class="p ">)</span><span class="p ">;</span>
    <span class="p ">}</span><span class="p ">)</span><span class="p ">;</span>
  <span class="p ">}</span><span class="p ">)</span><span class="p ">;</span>
<span class="p ">}</span></pre>
<p>Asynchronous tests: if callbacks expect between 0 and 2 positional arguments,
depending on the suffix of expectAsyncX(). expectAsyncX() will wrap a
function into a new callback and will not consider the test complete until
that callback is run. A count argument can be provided to specify the number
of times the callback should be called (the default is 1).</p>
<pre><span class="k ">import</span> <span class="s si">'package:unittest/unittest.dart'</span><span class="p ">;</span>
<span class="k ">import</span> <span class="s si">'dart:isolate'</span><span class="p ">;</span>
<span class="i ">main</span><span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
  <span class="i ">test</span><span class="p ">(</span><span class="s si">'callback is executed once'</span><span class="p ">,</span> <span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
    <span class="c ">// wrap the callback of an asynchronous call with [expectAsync0] if</span>
    <span class="c ">// the callback takes 0 arguments...</span>
    <span class="k ">var</span> <span class="i ">timer</span> <span class="o ">=</span> <span class="k ">new</span> <span class="t ">Timer</span><span class="p ">(</span><span class="n ">0</span><span class="p ">,</span> <span class="p ">(</span><span class="i ">_</span><span class="p ">)</span> <span class="a ">=&gt;</span> <span class="i ">expectAsync0</span><span class="p ">(</span><span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
      <span class="t ">int</span> <span class="i ">x</span> <span class="o ">=</span> <span class="n ">2</span> <span class="o ">+</span> <span class="n ">3</span><span class="p ">;</span>
      <span class="i ">expect</span><span class="p ">(</span><span class="i ">x</span><span class="p ">,</span> <span class="i ">equals</span><span class="p ">(</span><span class="n ">5</span><span class="p ">)</span><span class="p ">)</span><span class="p ">;</span>
    <span class="p ">}</span><span class="p ">)</span><span class="p ">)</span><span class="p ">;</span>
  <span class="p ">}</span><span class="p ">)</span><span class="p ">;</span>

  <span class="i ">test</span><span class="p ">(</span><span class="s si">'callback is executed twice'</span><span class="p ">,</span> <span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
    <span class="k ">var</span> <span class="i ">callback</span> <span class="o ">=</span> <span class="p ">(</span><span class="i ">_</span><span class="p ">)</span> <span class="a ">=&gt;</span> <span class="i ">expectAsync0</span><span class="p ">(</span><span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
      <span class="t ">int</span> <span class="i ">x</span> <span class="o ">=</span> <span class="n ">2</span> <span class="o ">+</span> <span class="n ">3</span><span class="p ">;</span>
      <span class="i ">expect</span><span class="p ">(</span><span class="i ">x</span><span class="p ">,</span> <span class="i ">equals</span><span class="p ">(</span><span class="n ">5</span><span class="p ">)</span><span class="p ">)</span><span class="p ">;</span>
    <span class="p ">}</span><span class="p ">,</span> <span class="i ">count</span><span class="p ">:</span> <span class="n ">2</span><span class="p ">)</span><span class="p ">;</span> <span class="c ">// &lt;-- we can indicate multiplicity to [expectAsync0]</span>
    <span class="k ">new</span> <span class="t ">Timer</span><span class="p ">(</span><span class="n ">0</span><span class="p ">,</span> <span class="i ">callback</span><span class="p ">)</span><span class="p ">;</span>
    <span class="k ">new</span> <span class="t ">Timer</span><span class="p ">(</span><span class="n ">0</span><span class="p ">,</span> <span class="i ">callback</span><span class="p ">)</span><span class="p ">;</span>
  <span class="p ">}</span><span class="p ">)</span><span class="p ">;</span>
<span class="p ">}</span></pre>
<p>expectAsyncX() will wrap the callback code in a try/catch handler to handle
exceptions (treated as test failures). There may be times when the number of
times a callback should be called is non-deterministic. In this case a dummy
callback can be created with expectAsync0((){}) and this can be called from
the real callback when it is finally complete. In this case the body of the
callback should be protected within a call to guardAsync(); this will ensure
that exceptions are properly handled.</p>
<p>Note: due to some language limitations we have to use different functions
depending on the number of positional arguments of the callback. In the
future, we plan to expose a single <code>expectAsync</code> function that can be used
regardless of the number of positional arguments. This requires new langauge
features or fixes to the current spec (e.g. see
<a href="http://dartbug.com/2706">Issue 2706</a>).</p>
<p>Meanwhile, we plan to add this alternative API for callbacks of more than 2
arguments or that take named parameters. (this is not implemented yet,
but will be coming here soon).</p>
<pre><span class="k ">import</span> <span class="s si">'package:unittest/unittest.dart'</span><span class="p ">;</span>
<span class="k ">import</span> <span class="s si">'dart:isolate'</span><span class="p ">;</span>
<span class="i ">main</span><span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
  <span class="i ">test</span><span class="p ">(</span><span class="s si">'callback is executed'</span><span class="p ">,</span> <span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
    <span class="c ">// indicate ahead of time that an async callback is expected.</span>
    <span class="k ">var</span> <span class="i ">async</span> <span class="o ">=</span> <span class="i ">startAsync</span><span class="p ">(</span><span class="p ">)</span><span class="p ">;</span>
    <span class="k ">new</span> <span class="t ">Timer</span><span class="p ">(</span><span class="n ">0</span><span class="p ">,</span> <span class="p ">(</span><span class="i ">_</span><span class="p ">)</span> <span class="p ">{</span>
      <span class="c ">// Guard the body of the callback, so errors are propagated</span>
      <span class="c ">// correctly.</span>
      <span class="i ">guardAsync</span><span class="p ">(</span><span class="p ">(</span><span class="p ">)</span> <span class="p ">{</span>
        <span class="t ">int</span> <span class="i ">x</span> <span class="o ">=</span> <span class="n ">2</span> <span class="o ">+</span> <span class="n ">3</span><span class="p ">;</span>
        <span class="i ">expect</span><span class="p ">(</span><span class="i ">x</span><span class="p ">,</span> <span class="i ">equals</span><span class="p ">(</span><span class="n ">5</span><span class="p ">)</span><span class="p ">)</span><span class="p ">;</span>
      <span class="p ">}</span><span class="p ">)</span><span class="p ">;</span>
      <span class="c ">// indicate that the asynchronous callback was invoked.</span>
      <span class="i ">async</span><span class="p ">.</span><span class="i ">complete</span><span class="p ">(</span><span class="p ">)</span><span class="p ">;</span>
    <span class="p ">}</span><span class="p ">)</span><span class="p ">;</span>
  <span class="p ">}</span><span class="p ">)</span><span class="p ">;</span>
<span class="p ">}</span></pre></div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="config">
<button class="show-code">Code</button>
final <a href="unittest/Configuration.html">Configuration</a>         <strong>config</strong> <a class="anchor-link"
            href="#config"
            title="Permalink to config">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Configuration get config =&gt; _config;
</pre>
</div>
</div>
<div class="field"><h4 id="ERROR">
<button class="show-code">Code</button>
const         <strong>ERROR</strong> <a class="anchor-link"
            href="#ERROR"
            title="Permalink to ERROR">#</a>
        </h4>
        <div class="doc">
<pre class="source">
ERROR = 'error'
</pre>
</div>
</div>
<div class="field"><h4 id="FAIL">
<button class="show-code">Code</button>
const         <strong>FAIL</strong> <a class="anchor-link"
            href="#FAIL"
            title="Permalink to FAIL">#</a>
        </h4>
        <div class="doc">
<pre class="source">
FAIL  = 'fail'
</pre>
</div>
</div>
<div class="field"><h4 id="groupSep">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>groupSep</strong> <a class="anchor-link"
            href="#groupSep"
            title="Permalink to groupSep">#</a>
        </h4>
        <div class="doc">
<pre class="source">
groupSep = ' '
</pre>
</div>
</div>
<div class="field"><h4 id="PASS">
<button class="show-code">Code</button>
const         <strong>PASS</strong> <a class="anchor-link"
            href="#PASS"
            title="Permalink to PASS">#</a>
        </h4>
        <div class="doc">
<pre class="source">
PASS  = 'pass'
</pre>
</div>
</div>
<div class="field"><h4 id="testCases">
<button class="show-code">Code</button>
final         <strong>testCases</strong> <a class="anchor-link"
            href="#testCases"
            title="Permalink to testCases">#</a>
        </h4>
        <div class="doc">
<p>Get the list of tests. </p>
<pre class="source">
get testCases =&gt; _tests;
</pre>
</div>
</div>
<div class="field"><h4 id="testState">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Map.html">Map</a>         <strong>testState</strong> <a class="anchor-link"
            href="#testState"
            title="Permalink to testState">#</a>
        </h4>
        <div class="doc">
<pre class="source">
testState = {}
</pre>
</div>
</div>
</div>
<div>
<h3>Functions</h3>
<div class="method"><h4 id="disableTest">
<button class="show-code">Code</button>
void <strong>disableTest</strong>(<a href="http://api.dartlang.org/dart_core/int.html">int</a> testId) <a class="anchor-link" href="#disableTest"
              title="Permalink to disableTest">#</a></h4>
<div class="doc">
<p>Disable a test by ID. </p>
<pre class="source">
void disableTest(int testId) =&gt; _setTestEnabledState(testId, false);
</pre>
</div>
</div>
<div class="method"><h4 id="enableTest">
<button class="show-code">Code</button>
void <strong>enableTest</strong>(<a href="http://api.dartlang.org/dart_core/int.html">int</a> testId) <a class="anchor-link" href="#enableTest"
              title="Permalink to enableTest">#</a></h4>
<div class="doc">
<p>Enable a test by ID. </p>
<pre class="source">
void enableTest(int testId) =&gt; _setTestEnabledState(testId, true);
</pre>
</div>
</div>
<div class="method"><h4 id="setSoloTest">
<button class="show-code">Code</button>
void <strong>setSoloTest</strong>(<a href="http://api.dartlang.org/dart_core/int.html">int</a> id) <a class="anchor-link" href="#setSoloTest"
              title="Permalink to setSoloTest">#</a></h4>
<div class="doc">
<p>Select a solo test by ID. </p>
<pre class="source">
void setSoloTest(int id) {
 for (var i = 0; i &lt; _tests.length; i++) {
   if (_tests[i].id == id) {
     _soloTest = _tests[i];
     break;
   }
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="ensureInitialized">
<button class="show-code">Code</button>
<strong>ensureInitialized</strong>() <a class="anchor-link" href="#ensureInitialized"
              title="Permalink to ensureInitialized">#</a></h4>
<div class="doc">
<p>Lazily initializes the test library if not already initialized.</p>
<pre class="source">
ensureInitialized() {
 if (_initialized) {
   return;
 }
 _initialized = true;
 // Hook our async guard into the matcher library.
 wrapAsync = expectAsync1;

 _tests = &lt;TestCase&gt;[];
 _testRunner = _nextBatch;
 _uncaughtErrorMessage = null;

 if (_config == null) {
   _config = new Configuration();
 }
 _config.onInit();

 if (_config.autoStart) {
   // Immediately queue the suite up. It will run after a timeout (i.e. after
   // main() has returned).
   _defer(runTests);
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="fail">
<button class="show-code">Code</button>
void <strong>fail</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> message) <a class="anchor-link" href="#fail"
              title="Permalink to fail">#</a></h4>
<div class="doc">
<pre class="source">
void fail(String message) {
 throw new ExpectException(message);
}
</pre>
</div>
</div>
<div class="method"><h4 id="registerException">
<button class="show-code">Code</button>
<strong>registerException</strong>(e, [trace]) <a class="anchor-link" href="#registerException"
              title="Permalink to registerException">#</a></h4>
<div class="doc">
<p>Registers that an exception was caught for the current test.</p>
<pre class="source">
registerException(e, [trace]) {
 _registerException(_currentTest, e, trace);
}
</pre>
</div>
</div>
<div class="method"><h4 id="guardAsync">
<button class="show-code">Code</button>
<strong>guardAsync</strong>(tryBody, [finallyBody, testNum = -1]) <a class="anchor-link" href="#guardAsync"
              title="Permalink to guardAsync">#</a></h4>
<div class="doc">
<p>Run 
<span class="param">tryBody</span> guarded in a try-catch block. If an exception is thrown, update
the <a class="crossref" href="unittest.html#_currentTest">_currentTest</a> status accordingly.</p>
<pre class="source">
guardAsync(tryBody, [finallyBody, testNum = -1]) {
 if (testNum &lt; 0) testNum = _currentTest;
 try {
   return tryBody();
 } catch (e, trace) {
   _registerException(testNum, e, trace);
 } finally {
   if (finallyBody != null) finallyBody();
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="runTests">
<button class="show-code">Code</button>
<strong>runTests</strong>() <a class="anchor-link" href="#runTests"
              title="Permalink to runTests">#</a></h4>
<div class="doc">
<p>Runs all queued tests, one at a time. </p>
<pre class="source">
runTests() {
 _currentTest = 0;
 _currentGroup = '';

 // If we are soloing a test, remove all the others.
 if (_soloTest != null) {
   filterTests((t) =&gt; t == _soloTest);
 }

 _config.onStart();

 _defer(() {
   _testRunner();
 });
}
</pre>
</div>
</div>
<div class="method"><h4 id="filterTests">
<button class="show-code">Code</button>
void <strong>filterTests</strong>(testFilter) <a class="anchor-link" href="#filterTests"
              title="Permalink to filterTests">#</a></h4>
<div class="doc">
<p>Filter the tests. 
<span class="param">testFilter</span> can be a <code>RegExp</code>, a <code>String</code> or a
predicate function. This is different to enabling/disabling tests
in that it removes the tests completely.</p>
<pre class="source">
void filterTests(testFilter) {
 var filterFunction;
 if (testFilter is String) {
   RegExp re = new RegExp(testFilter);
   filterFunction = (t) =&gt; re.hasMatch(t.description);
 } else if (testFilter is RegExp) {
   filterFunction = (t) =&gt; testFilter.hasMatch(t.description);
 } else if (testFilter is Function) {
   filterFunction = testFilter;
 }
 _tests = _tests.where(filterFunction).toList();
}
</pre>
</div>
</div>
<div class="method"><h4 id="rerunTests">
<button class="show-code">Code</button>
<strong>rerunTests</strong>() <a class="anchor-link" href="#rerunTests"
              title="Permalink to rerunTests">#</a></h4>
<div class="doc">
<pre class="source">
rerunTests() {
 _uncaughtErrorMessage = null;
 _initialized = true; // We don't want to reset the test array.
 runTests();
}
</pre>
</div>
</div>
<div class="method"><h4 id="callbackDone">
<button class="show-code">Code</button>
void <strong>callbackDone</strong>() <a class="anchor-link" href="#callbackDone"
              title="Permalink to callbackDone">#</a></h4>
<div class="doc">
<p>Temporary hack: expose old API.
TODO(gram) remove this when WebKit tests are working with new framework</p>
<pre class="source">
void callbackDone() {
 _handleCallbackFunctionComplete(_currentTest);
}
</pre>
</div>
</div>
<div class="method"><h4 id="tearDown">
<button class="show-code">Code</button>
void <strong>tearDown</strong>(<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> teardownTest) <a class="anchor-link" href="#tearDown"
              title="Permalink to tearDown">#</a></h4>
<div class="doc">
<p>Register a <a class="crossref" href="unittest.html#tearDown">tearDown</a> function for a test <a class="crossref" href="unittest.html#group">group</a>. This function will
be called after each test in the group is run. Note that if groups
are nested only the most locally scoped <a class="crossref" href="unittest.html#tearDown">tearDown</a> function will be run.
<a class="crossref" href="unittest.html#setUp">setUp</a> and <a class="crossref" href="unittest.html#tearDown">tearDown</a> should be called within the <a class="crossref" href="unittest.html#group">group</a> before any
calls to <a class="crossref" href="unittest.html#test">test</a>.</p>
<pre class="source">
void tearDown(Function teardownTest) {
 _testTeardown = teardownTest;
}
</pre>
</div>
</div>
<div class="method"><h4 id="setUp">
<button class="show-code">Code</button>
void <strong>setUp</strong>(<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> setupTest) <a class="anchor-link" href="#setUp"
              title="Permalink to setUp">#</a></h4>
<div class="doc">
<p>Register a <a class="crossref" href="unittest.html#setUp">setUp</a> function for a test <a class="crossref" href="unittest.html#group">group</a>. This function will
be called before each test in the group is run. Note that if groups
are nested only the most locally scoped <a class="crossref" href="unittest.html#setUp">setUp</a> function will be run.
<a class="crossref" href="unittest.html#setUp">setUp</a> and <a class="crossref" href="unittest.html#tearDown">tearDown</a> should be called within the <a class="crossref" href="unittest.html#group">group</a> before any
calls to <a class="crossref" href="unittest.html#test">test</a>.</p>
<pre class="source">
void setUp(Function setupTest) {
 _testSetup = setupTest;
}
</pre>
</div>
</div>
<div class="method"><h4 id="group">
<button class="show-code">Code</button>
void <strong>group</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> description, void body()) <a class="anchor-link" href="#group"
              title="Permalink to group">#</a></h4>
<div class="doc">
<p>Creates a new named group of tests. Calls to group() or test() within the
body of the function passed to this will inherit this group's description.</p>
<pre class="source">
void group(String description, void body()) {
 ensureInitialized();
 // Concatenate the new group.
 final parentGroup = _currentGroup;
 if (_currentGroup != '') {
   // Add a space.
   _currentGroup = '$_currentGroup$groupSep$description';
 } else {
   // The first group.
   _currentGroup = description;
 }

 // Groups can be nested, so we need to preserve the current
 // settings for test setup/teardown.
 Function parentSetup = _testSetup;
 Function parentTeardown = _testTeardown;

 try {
   _testSetup = null;
   _testTeardown = null;
   body();
 } catch (e, trace) {
   var stack = (trace == null) ? '' : ': ${trace.toString()}';
   _uncaughtErrorMessage = "${e.toString()}$stack";
 } finally {
   // Now that the group is over, restore the previous one.
   _currentGroup = parentGroup;
   _testSetup = parentSetup;
   _testTeardown = parentTeardown;
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="protectAsync2">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> <strong>protectAsync2</strong>(<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> callback) <a class="anchor-link" href="#protectAsync2"
              title="Permalink to protectAsync2">#</a></h4>
<div class="doc">
<p>Like <a class="crossref" href="unittest.html#protectAsync0">protectAsync0</a> but 
<span class="param">callback</span> should take 2 positional arguments.</p>
<pre class="source">
Function protectAsync2(Function callback) {
 return new _SpreadArgsHelper.optionalCalls(callback).invoke2;
}
</pre>
</div>
</div>
<div class="method"><h4 id="protectAsync1">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> <strong>protectAsync1</strong>(<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> callback) <a class="anchor-link" href="#protectAsync1"
              title="Permalink to protectAsync1">#</a></h4>
<div class="doc">
<p>Like <a class="crossref" href="unittest.html#protectAsync0">protectAsync0</a> but 
<span class="param">callback</span> should take 1 positional argument.</p>
<pre class="source">
Function protectAsync1(Function callback) {
 return new _SpreadArgsHelper.optionalCalls(callback).invoke1;
}
</pre>
</div>
</div>
<div class="method"><h4 id="protectAsync0">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> <strong>protectAsync0</strong>(<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> callback) <a class="anchor-link" href="#protectAsync0"
              title="Permalink to protectAsync0">#</a></h4>
<div class="doc">
<p>Wraps the 
<span class="param">callback</span> in a new function and returns that function. The new
function will be able to handle exceptions by directing them to the correct
test. This is thus similar to expectAsync0. Use it to wrap any callbacks that
might optionally be called but may never be called during the test.

<span class="param">callback</span> should take 0 positional arguments (named arguments are not
supported).</p>
<pre class="source">
Function protectAsync0(Function callback) {
 return new _SpreadArgsHelper.optionalCalls(callback).invoke0;
}
</pre>
</div>
</div>
<div class="method"><h4 id="expectAsyncUntil2">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> <strong>expectAsyncUntil2</strong>(<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> callback, <a href="http://api.dartlang.org/dart_core/Function.html">Function</a> isDone) <a class="anchor-link" href="#expectAsyncUntil2"
              title="Permalink to expectAsyncUntil2">#</a></h4>
<div class="doc">
<p>Like <a class="crossref" href="unittest.html#expectAsyncUntil0">expectAsyncUntil0</a> but 
<span class="param">callback</span> should take 2 positional arguments.</p>
<pre class="source">
Function expectAsyncUntil2(Function callback, Function isDone) {
 return new _SpreadArgsHelper.variableCallCount(callback, isDone).invoke2;
}
</pre>
</div>
</div>
<div class="method"><h4 id="expectAsyncUntil1">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> <strong>expectAsyncUntil1</strong>(<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> callback, <a href="http://api.dartlang.org/dart_core/Function.html">Function</a> isDone) <a class="anchor-link" href="#expectAsyncUntil1"
              title="Permalink to expectAsyncUntil1">#</a></h4>
<div class="doc">
<p>Like <a class="crossref" href="unittest.html#expectAsyncUntil0">expectAsyncUntil0</a> but 
<span class="param">callback</span> should take 1 positional argument.</p>
<pre class="source">
Function expectAsyncUntil1(Function callback, Function isDone) {
 return new _SpreadArgsHelper.variableCallCount(callback, isDone).invoke1;
}
</pre>
</div>
</div>
<div class="method"><h4 id="expectAsyncUntil0">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> <strong>expectAsyncUntil0</strong>(<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> callback, <a href="http://api.dartlang.org/dart_core/Function.html">Function</a> isDone) <a class="anchor-link" href="#expectAsyncUntil0"
              title="Permalink to expectAsyncUntil0">#</a></h4>
<div class="doc">
<p>Indicate that 
<span class="param">callback</span> is expected to be called until 
<span class="param">isDone</span> returns
true. The unittest framework check 
<span class="param">isDone</span> after each callback and only
when it returns true will it continue with the following test. Using
<a class="crossref" href="unittest.html#expectAsyncUntil0">expectAsyncUntil0</a> will also ensure that errors that occur within

<span class="param">callback</span> are tracked and reported. 
<span class="param">callback</span> should take 0 positional
arguments (named arguments are not supported).</p>
<pre class="source">
Function expectAsyncUntil0(Function callback, Function isDone) {
 return new _SpreadArgsHelper.variableCallCount(callback, isDone).invoke0;
}
</pre>
</div>
</div>
<div class="method"><h4 id="expectAsync2">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> <strong>expectAsync2</strong>(<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> callback, {<a href="http://api.dartlang.org/dart_core/int.html">int</a> count: 1}) <a class="anchor-link" href="#expectAsync2"
              title="Permalink to expectAsync2">#</a></h4>
<div class="doc">
<p>Like <a class="crossref" href="unittest.html#expectAsync0">expectAsync0</a> but 
<span class="param">callback</span> should take 2 positional arguments. </p>
<pre class="source">
Function expectAsync2(Function callback, {int count: 1}) {
 return new _SpreadArgsHelper.fixedCallCount(callback, count).invoke2;
}
</pre>
</div>
</div>
<div class="method"><h4 id="expectAsync1">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> <strong>expectAsync1</strong>(<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> callback, {<a href="http://api.dartlang.org/dart_core/int.html">int</a> count: 1}) <a class="anchor-link" href="#expectAsync1"
              title="Permalink to expectAsync1">#</a></h4>
<div class="doc">
<p>Like <a class="crossref" href="unittest.html#expectAsync0">expectAsync0</a> but 
<span class="param">callback</span> should take 1 positional argument. </p>
<pre class="source">
Function expectAsync1(Function callback, {int count: 1}) {
 return new _SpreadArgsHelper.fixedCallCount(callback, count).invoke1;
}
</pre>
</div>
</div>
<div class="method"><h4 id="expectAsync0">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> <strong>expectAsync0</strong>(<a href="http://api.dartlang.org/dart_core/Function.html">Function</a> callback, {<a href="http://api.dartlang.org/dart_core/int.html">int</a> count: 1}) <a class="anchor-link" href="#expectAsync0"
              title="Permalink to expectAsync0">#</a></h4>
<div class="doc">
<p>Indicate that 
<span class="param">callback</span> is expected to be called a 
<span class="param">count</span> number of times
(by default 1). The unittest framework will wait for the callback to run the
specified 
<span class="param">count</span> times before it continues with the following test.  Using
<a class="crossref" href="unittest.html#expectAsync0">expectAsync0</a> will also ensure that errors that occur within 
<span class="param">callback</span> are
tracked and reported. 
<span class="param">callback</span> should take 0 positional arguments (named
arguments are not supported).</p>
<pre class="source">
Function expectAsync0(Function callback, {int count: 1}) {
 return new _SpreadArgsHelper.fixedCallCount(callback, count).invoke0;
}
</pre>
</div>
</div>
<div class="method"><h4 id="solo_test">
<button class="show-code">Code</button>
void <strong>solo_test</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> spec, <a href="unittest/TestFunction.html">TestFunction</a> body) <a class="anchor-link" href="#solo_test"
              title="Permalink to solo_test">#</a></h4>
<div class="doc">
<p>Creates a new test case with the given description and body. The
description will include the descriptions of any surrounding group()
calls.</p>
<p>"solo<em>" means that this will be the only test that is run. All other tests
will be skipped. This is a convenience function to let you quickly isolate
a single test by adding "solo</em>" before it to temporarily disable all other
tests.</p>
<pre class="source">
void solo_test(String spec, TestFunction body) {
 // TODO(rnystrom): Support multiple solos. If more than one test is solo-ed,
 // all of the solo-ed tests and none of the non-solo-ed ones should run.
 if (_soloTest != null) {
   throw new Exception('Only one test can be soloed right now.');
 }

 ensureInitialized();

 _soloTest = new TestCase(_tests.length + 1, _fullSpec(spec), body, 0);
 _tests.add(_soloTest);
}
</pre>
</div>
</div>
<div class="method"><h4 id="asyncTest">
<button class="show-code">Code</button>
void <strong>asyncTest</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> spec, <a href="http://api.dartlang.org/dart_core/int.html">int</a> callbacks, <a href="unittest/TestFunction.html">TestFunction</a> body) <a class="anchor-link" href="#asyncTest"
              title="Permalink to asyncTest">#</a></h4>
<div class="doc">
<p>(Deprecated) Creates a new async test case with the given description
and body. The description will include the descriptions of any surrounding
group() calls.</p>
<pre class="source">
void asyncTest(String spec, int callbacks, TestFunction body) {
 ensureInitialized();

 final testCase = new TestCase(
     _tests.length + 1, _fullSpec(spec), body, callbacks);
 _tests.add(testCase);

 if (callbacks &lt; 1) {
   testCase.error(
       'Async tests must wait for at least one callback ', '');
 }
}
</pre>
</div>
</div>
<div class="method"><h4 id="test">
<button class="show-code">Code</button>
void <strong>test</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> spec, <a href="unittest/TestFunction.html">TestFunction</a> body) <a class="anchor-link" href="#test"
              title="Permalink to test">#</a></h4>
<div class="doc">
<p>Creates a new test case with the given description and body. The
description will include the descriptions of any surrounding group()
calls.</p>
<pre class="source">
void test(String spec, TestFunction body) {
 ensureInitialized();
 _tests.add(new TestCase(_tests.length + 1, _fullSpec(spec), body, 0));
}
</pre>
</div>
</div>
<div class="method"><h4 id="expectThrow">
<button class="show-code">Code</button>
void <strong>expectThrow</strong>(function, [<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> callback(exception)]) <a class="anchor-link" href="#expectThrow"
              title="Permalink to expectThrow">#</a></h4>
<div class="doc">
<p>(Deprecated) Evaluates the 
<span class="param">function</span> and validates that it throws an
exception. If 
<span class="param">callback</span> is provided, then it will be invoked with the
thrown exception. The callback may do any validation it wants. In addition,
if it returns <code>false</code>, that also indicates an expectation failure.</p>
<pre class="source">
void expectThrow(function, [bool callback(exception)]) {
 bool threw = false;
 try {
   function();
 } catch (e) {
   threw = true;

   // Also let the callback look at it.
   if (callback != null) {
     var result = callback(e);

     // If the callback explicitly returned false, treat that like an
     // expectation too. (If it returns null, though, don't.)
     if (result == false) {
       fail('Exception:\n$e\ndid not match expectation.');
     }
   }
 }

 if (threw != true) fail('An expected exception was not thrown.');
}
</pre>
</div>
</div>
<div class="method"><h4 id="logMessage">
<button class="show-code">Code</button>
void <strong>logMessage</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> message) <a class="anchor-link" href="#logMessage"
              title="Permalink to logMessage">#</a></h4>
<div class="doc">
<pre class="source">
void logMessage(String message) =&gt; _config.logMessage(message);
</pre>
</div>
</div>
<div class="method"><h4 id="configure">
<button class="show-code">Code</button>
<a href="unittest/Configuration.html">Configuration</a> <strong>configure</strong>(<a href="unittest/Configuration.html">Configuration</a> config) <a class="anchor-link" href="#configure"
              title="Permalink to configure">#</a></h4>
<div class="doc">
<p>Set the <a class="crossref" href="unittest/Configuration.html">Configuration</a> used by the unittest library. Returns any
previous configuration.
TODO: consider deprecating in favor of a setter now we have a getter.</p>
<pre class="source">
Configuration configure(Configuration config) {
 Configuration _oldConfig = _config;
 _config = config;
 return _oldConfig;
}
</pre>
</div>
</div>
</div>
<div>
<h3>Classes</h3>
          <div class="type">
          <h4>
            <a href="unittest/Configuration.html"><strong>Configuration</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="unittest/TestCase.html"><strong>TestCase</strong></a>
          </h4>
          </div>
          
</div>
<div>
<h3>Typedefs</h3>
          <div class="type">
          <h4>
            <a href="unittest/TestFunction.html"><strong>TestFunction</strong></a>
          </h4>
          </div>
          
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="client-live-nav.js"></script>
        </body></html>
        
