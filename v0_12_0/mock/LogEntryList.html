        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>LogEntryList class / mock Library / Dart Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="http://fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="mock" data-type="LogEntryList">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">Dart Documentation</a>
         &rsaquo; <a href="../mock.html">mock</a> &rsaquo; <a href="../mock/LogEntryList.html">LogEntryList</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>LogEntryList</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<p>We do verification on a list of <a class="crossref" href="../mock/LogEntry.html">LogEntry</a>s. To allow chaining
of calls to verify, we encapsulate such a list in the <a class="crossref" href="../mock/LogEntryList.html#LogEntryList">LogEntryList</a>
class.</p>
<pre class="source">
class LogEntryList {
 String filter;
 List&lt;LogEntry&gt; logs;
 LogEntryList([this.filter]) {
   logs = new List&lt;LogEntry&gt;();
 }

 /** Add a [LogEntry] to the log. */
 add(LogEntry entry) =&gt; logs.add(entry);

 /** Get the first entry, or null if no entries. */
 get first =&gt; (logs == null || logs.length == 0) ? null : logs[0];

 /** Get the last entry, or null if no entries. */
 get last =&gt; (logs == null || logs.length == 0) ? null : logs.last;

 /** Creates a LogEntry predicate function from the argument. */
 Function _makePredicate(arg) {
   if (arg == null) {
     return (e) =&gt; true;
   } else if (arg is CallMatcher) {
     return (e) =&gt; arg.matches(e.methodName, e.args);
   } else if (arg is Function) {
     return arg;
   } else {
     throw new Exception("Invalid argument to _makePredicate.");
   }
 }

 /**
  * Create a new [LogEntryList] consisting of [LogEntry]s from
  * this list that match the specified [mockNameFilter] and [logFilter].
  * [mockNameFilter] can be null, a [String], a predicate [Function],
  * or a [Matcher]. If [mockNameFilter] is null, this is the same as
  * [anything].
  * If [logFilter] is null, all entries in the log will be returned.
  * Otherwise [logFilter] should be a [CallMatcher] or  predicate function
  * that takes a [LogEntry] and returns a bool.
  * If [destructive] is true, the log entries are removed from the
  * original list.
  */
 LogEntryList getMatches([mockNameFilter,
                         logFilter,
                         Matcher actionMatcher,
                         bool destructive = false]) {
   if (mockNameFilter == null) {
     mockNameFilter = anything;
   } else {
     mockNameFilter = wrapMatcher(mockNameFilter);
   }
   Function entryFilter = _makePredicate(logFilter);
   String filterName = _qualifiedName(mockNameFilter, logFilter.toString());
   LogEntryList rtn = new LogEntryList(filterName);
   MatchState matchState = new MatchState();
   for (var i = 0; i &lt; logs.length; i++) {
     LogEntry entry = logs[i];
     if (mockNameFilter.matches(entry.mockName, matchState) &amp;&amp;
         entryFilter(entry)) {
       if (actionMatcher == null ||
           actionMatcher.matches(entry, matchState)) {
         rtn.add(entry);
         if (destructive) {
           logs.removeRange(i--, 1);
         }
       }
     }
   }
   return rtn;
 }

 /** Apply a unit test [Matcher] to the [LogEntryList]. */
 LogEntryList verify(Matcher matcher) {
   if (_mockFailureHandler == null) {
     _mockFailureHandler =
         new _MockFailureHandler(getOrCreateExpectFailureHandler());
   }
   expect(logs, matcher, reason:filter, failureHandler: _mockFailureHandler);
   return this;
 }

 /**
  * Iterate through the list and call the [validator] function with the
  * log [List] and position. The [validator] should return the number of
  * positions to advance upon success, or zero upon failure. When zero is
  * returned an error is reported. [reason] can be used to provide a
  * more descriptive failure message. If a failure occurred false will be
  * returned (unless the failure handler itself threw an exception);
  * otherwise true is returned.
  * The use case here is to perform more complex validations; for example
  * we may want to assert that the return value from some function is
  * later used as a parameter to a following function. If we filter the logs
  * to include just these two functions we can write a simple validator to
  * do this check.
  */
 bool stepwiseValidate(StepValidator validator, [String reason = '']) {
   if (_mockFailureHandler == null) {
     _mockFailureHandler =
         new _MockFailureHandler(getOrCreateExpectFailureHandler());
   }
   var i = 0;
   while (i &lt; logs.length) {
     var n = validator(logs, i);
     if (n == 0) {
       if (reason.length &gt; 0) {
         reason = ': $reason';
       }
       _mockFailureHandler.fail("Stepwise validation failed at $filter "
                                "position $i$reason");
       return false;
     } else {
       i += n;
     }
   }
   return true;
 }

 /**
  * Turn the logs into human-readable text. If [baseTime] is specified
  * then each entry is prefixed with the offset from that time in
  * milliseconds; otherwise the time of day is used.
  */
 String toString([DateTime baseTime]) {
   String s = '';
   for (var e in logs) {
     s = '$s${e.toString(baseTime)}\n';
   }
   return s;
 }

 /**
  *  Find the first log entry that satisfies [logFilter] and
  *  return its position. A search [start] position can be provided
  *  to allow for repeated searches. [logFilter] can be a [CallMatcher],
  *  or a predicate function that takes a [LogEntry] argument and returns
  *  a bool. If [logFilter] is null, it will match any [LogEntry].
  *  If no entry is found, then [failureReturnValue] is returned.
  *  After each check the position is updated by [skip], so using
  *  [skip] of -1 allows backward searches, using a [skip] of 2 can
  *  be used to check pairs of adjacent entries, and so on.
  */
 int findLogEntry(logFilter, [int start = 0, int failureReturnValue = -1,
     skip = 1]) {
   logFilter = _makePredicate(logFilter);
   int pos = start;
   while (pos &gt;= 0 &amp;&amp; pos &lt; logs.length) {
     if (logFilter(logs[pos])) {
       return pos;
     }
     pos += skip;
   }
   return failureReturnValue;
 }

 /**
  * Returns log events that happened up to the first one that
  * satisfies [logFilter]. If [inPlace] is true, then returns
  * this LogEntryList after removing the from the first satisfier;
  * onwards otherwise a new list is created. [description]
  * is used to create a new name for the resulting list.
  * [defaultPosition] is used as the index of the matching item in
  * the case that no match is found.
  */
 LogEntryList _head(logFilter, bool inPlace,
                    String description, int defaultPosition) {
   if (filter != null) {
     description = '$filter $description';
   }
   int pos = findLogEntry(logFilter, 0, defaultPosition);
   if (inPlace) {
     if (pos &lt; logs.length) {
       logs.removeRange(pos, logs.length - pos);
     }
     filter = description;
     return this;
   } else {
     LogEntryList newList = new LogEntryList(description);
     for (var i = 0; i &lt; pos; i++) {
       newList.logs.add(logs[i]);
     }
     return newList;
   }
 }

 /**
  * Returns log events that happened from the first one that
  * satisfies [logFilter]. If [inPlace] is true, then returns
  * this LogEntryList after removing the entries up to the first
  * satisfier; otherwise a new list is created. [description]
  * is used to create a new name for the resulting list.
  * [defaultPosition] is used as the index of the matching item in
  * the case that no match is found.
  */
 LogEntryList _tail(logFilter, bool inPlace,
                    String description, int defaultPosition) {
   if (filter != null) {
     description = '$filter $description';
   }
   int pos = findLogEntry(logFilter, 0, defaultPosition);
   if (inPlace) {
     if (pos &gt; 0) {
       logs.removeRange(0, pos);
     }
     filter = description;
     return this;
   } else {
     LogEntryList newList = new LogEntryList(description);
     while (pos &lt; logs.length) {
       newList.logs.add(logs[pos++]);
     }
     return newList;
   }
 }

 /**
  * Returns log events that happened after [when]. If [inPlace]
  * is true, then it returns this LogEntryList after removing
  * the entries that happened up to [when]; otherwise a new
  * list is created.
  */
 LogEntryList after(DateTime when, [bool inPlace = false]) =&gt;
     _tail((e) =&gt; e.time &gt; when, inPlace, 'after $when', logs.length);

 /**
  * Returns log events that happened from [when] onwards. If
  * [inPlace] is true, then it returns this LogEntryList after
  * removing the entries that happened before [when]; otherwise
  * a new list is created.
  */
 LogEntryList from(DateTime when, [bool inPlace = false]) =&gt;
     _tail((e) =&gt; e.time &gt;= when, inPlace, 'from $when', logs.length);

 /**
  * Returns log events that happened until [when]. If [inPlace]
  * is true, then it returns this LogEntryList after removing
  * the entries that happened after [when]; otherwise a new
  * list is created.
  */
 LogEntryList until(DateTime when, [bool inPlace = false]) =&gt;
     _head((e) =&gt; e.time &gt; when, inPlace, 'until $when', logs.length);

 /**
  * Returns log events that happened before [when]. If [inPlace]
  * is true, then it returns this LogEntryList after removing
  * the entries that happened from [when] onwards; otherwise a new
  * list is created.
  */
 LogEntryList before(DateTime when, [bool inPlace = false]) =&gt;
     _head((e) =&gt; e.time &gt;= when, inPlace, 'before $when', logs.length);

 /**
  * Returns log events that happened after [logEntry]'s time.
  * If [inPlace] is true, then it returns this LogEntryList after
  * removing the entries that happened up to [when]; otherwise a new
  * list is created. If [logEntry] is null the current time is used.
  */
 LogEntryList afterEntry(LogEntry logEntry, [bool inPlace = false]) =&gt;
     after(logEntry == null ? new DateTime.now() : logEntry.time);

 /**
  * Returns log events that happened from [logEntry]'s time onwards.
  * If [inPlace] is true, then it returns this LogEntryList after
  * removing the entries that happened before [when]; otherwise
  * a new list is created. If [logEntry] is null the current time is used.
  */
 LogEntryList fromEntry(LogEntry logEntry, [bool inPlace = false]) =&gt;
     from(logEntry == null ? new DateTime.now() : logEntry.time);

 /**
  * Returns log events that happened until [logEntry]'s time. If
  * [inPlace] is true, then it returns this LogEntryList after removing
  * the entries that happened after [when]; otherwise a new
  * list is created. If [logEntry] is null the epoch time is used.
  */
 LogEntryList untilEntry(LogEntry logEntry, [bool inPlace = false]) =&gt;
     until(logEntry == null ?
         new DateTime.fromMillisecondsSinceEpoch(0) : logEntry.time);

 /**
  * Returns log events that happened before [logEntry]'s time. If
  * [inPlace] is true, then it returns this LogEntryList after removing
  * the entries that happened from [when] onwards; otherwise a new
  * list is created. If [logEntry] is null the epoch time is used.
  */
 LogEntryList beforeEntry(LogEntry logEntry, [bool inPlace = false]) =&gt;
     before(logEntry == null ?
         new DateTime.fromMillisecondsSinceEpoch(0) : logEntry.time);

 /**
  * Returns log events that happened after the first event in [segment].
  * If [inPlace] is true, then it returns this LogEntryList after removing
  * the entries that happened earlier; otherwise a new list is created.
  */
 LogEntryList afterFirst(LogEntryList segment, [bool inPlace = false]) =&gt;
     afterEntry(segment.first, inPlace);

 /**
  * Returns log events that happened after the last event in [segment].
  * If [inPlace] is true, then it returns this LogEntryList after removing
  * the entries that happened earlier; otherwise a new list is created.
  */
 LogEntryList afterLast(LogEntryList segment, [bool inPlace = false]) =&gt;
     afterEntry(segment.last, inPlace);

 /**
  * Returns log events that happened from the time of the first event in
  * [segment] onwards. If [inPlace] is true, then it returns this
  * LogEntryList after removing the earlier entries; otherwise a new list
  * is created.
  */
 LogEntryList fromFirst(LogEntryList segment, [bool inPlace = false]) =&gt;
     fromEntry(segment.first, inPlace);

 /**
  * Returns log events that happened from the time of the last event in
  * [segment] onwards. If [inPlace] is true, then it returns this
  * LogEntryList after removing the earlier entries; otherwise a new list
  * is created.
  */
 LogEntryList fromLast(LogEntryList segment, [bool inPlace = false]) =&gt;
     fromEntry(segment.last, inPlace);

 /**
  * Returns log events that happened until the first event in [segment].
  * If [inPlace] is true, then it returns this LogEntryList after removing
  * the entries that happened later; otherwise a new list is created.
  */
 LogEntryList untilFirst(LogEntryList segment, [bool inPlace = false]) =&gt;
     untilEntry(segment.first, inPlace);

 /**
  * Returns log events that happened until the last event in [segment].
  * If [inPlace] is true, then it returns this LogEntryList after removing
  * the entries that happened later; otherwise a new list is created.
  */
 LogEntryList untilLast(LogEntryList segment, [bool inPlace = false]) =&gt;
     untilEntry(segment.last, inPlace);

 /**
  * Returns log events that happened before the first event in [segment].
  * If [inPlace] is true, then it returns this LogEntryList after removing
  * the entries that happened later; otherwise a new list is created.
  */
 LogEntryList beforeFirst(LogEntryList segment, [bool inPlace = false]) =&gt;
     beforeEntry(segment.first, inPlace);

 /**
  * Returns log events that happened before the last event in [segment].
  * If [inPlace] is true, then it returns this LogEntryList after removing
  * the entries that happened later; otherwise a new list is created.
  */
 LogEntryList beforeLast(LogEntryList segment, [bool inPlace = false]) =&gt;
     beforeEntry(segment.last, inPlace);

 /**
  * Iterate through the LogEntryList looking for matches to the entries
  * in [keys]; for each match found the closest [distance] neighboring log
  * entries that match [mockNameFilter] and [logFilter] will be included in
  * the result. If [isPreceding] is true we use the neighbors that precede
  * the matched entry; else we use the neighbors that followed.
  * If [includeKeys] is true then the entries in [keys] that resulted in
  * entries in the output list are themselves included in the output list. If
  * [distance] is zero then all matches are included.
  */
 LogEntryList _neighboring(bool isPreceding,
                           LogEntryList keys,
                           mockNameFilter,
                           logFilter,
                           int distance,
                           bool includeKeys) {
   String filterName = 'Calls to '
       '${_qualifiedName(mockNameFilter, logFilter.toString())} '
       '${isPreceding?"preceding":"following"} ${keys.filter}';

   LogEntryList rtn = new LogEntryList(filterName);

   // Deal with the trivial case.
   if (logs.length == 0 || keys.logs.length == 0) {
     return rtn;
   }

   // Normalize the mockNameFilter and logFilter values.
   if (mockNameFilter == null) {
     mockNameFilter = anything;
   } else {
     mockNameFilter = wrapMatcher(mockNameFilter);
   }
   logFilter = _makePredicate(logFilter);

   // The scratch list is used to hold matching entries when we
   // are doing preceding neighbors. The remainingCount is used to
   // keep track of how many matching entries we can still add in the
   // current segment (0 if we are doing doing following neighbors, until
   // we get our first key match).
   List scratch = null;
   int remainingCount = 0;
   if (isPreceding) {
     scratch = new List();
     remainingCount = logs.length;
   }

   var keyIterator = keys.logs.iterator;
   keyIterator.moveNext();
   LogEntry keyEntry = keyIterator.current;
   MatchState matchState = new MatchState();

   for (LogEntry logEntry in logs) {
     // If we have a log entry match, copy the saved matches from the
     // scratch buffer into the return list, as well as the matching entry,
     // if appropriate, and reset the scratch buffer. Continue processing
     // from the next key entry.
     if (keyEntry == logEntry) {
       if (scratch != null) {
         int numToCopy = scratch.length;
         if (distance &gt; 0 &amp;&amp; distance &lt; numToCopy) {
           numToCopy = distance;
         }
         for (var i = scratch.length - numToCopy; i &lt; scratch.length; i++) {
           rtn.logs.add(scratch[i]);
         }
         scratch.clear();
       } else {
         remainingCount = distance &gt; 0 ? distance : logs.length;
       }
       if (includeKeys) {
         rtn.logs.add(keyEntry);
       }
       if (keyIterator.moveNext()) {
         keyEntry = keyIterator.current;
       } else if (isPreceding) { // We're done.
         break;
       }
     } else if (remainingCount &gt; 0 &amp;&amp;
                mockNameFilter.matches(logEntry.mockName, matchState) &amp;&amp;
                logFilter(logEntry)) {
       if (scratch != null) {
         scratch.add(logEntry);
       } else {
         rtn.logs.add(logEntry);
         --remainingCount;
       }
     }
   }
   return rtn;
 }

 /**
  * Iterate through the LogEntryList looking for matches to the entries
  * in [keys]; for each match found the closest [distance] prior log entries
  * that match [mocknameFilter] and [logFilter] will be included in the result.
  * If [includeKeys] is true then the entries in [keys] that resulted in
  * entries in the output list are themselves included in the output list. If
  * [distance] is zero then all matches are included.
  *
  * The idea here is that you could find log entries that are related to
  * other logs entries in some temporal sense. For example, say we have a
  * method commit() that returns -1 on failure. Before commit() gets called
  * the value being committed is created by process(). We may want to find
  * the calls to process() that preceded calls to commit() that failed.
  * We could do this with:
  *
  *      print(log.preceding(log.getLogs(callsTo('commit'), returning(-1)),
  *          logFilter: callsTo('process')).toString());
  *
  * We might want to include the details of the failing calls to commit()
  * to see what parameters were passed in, in which case we would set
  * [includeKeys].
  *
  * As another simple example, say we wanted to know the three method
  * calls that immediately preceded each failing call to commit():
  *
  *     print(log.preceding(log.getLogs(callsTo('commit'), returning(-1)),
  *         distance: 3).toString());
  */
 LogEntryList preceding(LogEntryList keys,
                        {mockNameFilter: null,
                        logFilter: null,
                        int distance: 1,
                        bool includeKeys: false}) =&gt;
     _neighboring(true, keys, mockNameFilter, logFilter,
         distance, includeKeys);

 /**
  * Iterate through the LogEntryList looking for matches to the entries
  * in [keys]; for each match found the closest [distance] subsequent log
  * entries that match [mocknameFilter] and [logFilter] will be included in
  * the result. If [includeKeys] is true then the entries in [keys] that
  * resulted in entries in the output list are themselves included in the
  * output list. If [distance] is zero then all matches are included.
  * See [preceding] for a usage example.
  */
 LogEntryList following(LogEntryList keys,
                        {mockNameFilter: null,
                        logFilter: null,
                        int distance: 1,
                        bool includeKeys: false}) =&gt;
     _neighboring(false, keys, mockNameFilter, logFilter,
         distance, includeKeys);
}
</pre>
</div>
<div>
<h3>Constructors</h3>
<div class="method"><h4 id="LogEntryList">
<button class="show-code">Code</button>
new <strong>LogEntryList</strong>([String filter]) <a class="anchor-link" href="#LogEntryList"
              title="Permalink to LogEntryList.LogEntryList">#</a></h4>
<div class="doc">
<pre class="source">
LogEntryList([this.filter]) {
 logs = new List&lt;LogEntry&gt;();
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="filter">
<button class="show-code">Code</button>
String         <strong>filter</strong> <a class="anchor-link"
            href="#filter"
            title="Permalink to LogEntryList.filter">#</a>
        </h4>
        <div class="doc">
<pre class="source">
filter
</pre>
</div>
</div>
<div class="field"><h4 id="first">
<button class="show-code">Code</button>
final         <strong>first</strong> <a class="anchor-link"
            href="#first"
            title="Permalink to LogEntryList.first">#</a>
        </h4>
        <div class="doc">
<p>Get the first entry, or null if no entries. </p>
<pre class="source">
get first =&gt; (logs == null || logs.length == 0) ? null : logs[0];
</pre>
</div>
</div>
<div class="field"><h4 id="last">
<button class="show-code">Code</button>
final         <strong>last</strong> <a class="anchor-link"
            href="#last"
            title="Permalink to LogEntryList.last">#</a>
        </h4>
        <div class="doc">
<p>Get the last entry, or null if no entries. </p>
<pre class="source">
get last =&gt; (logs == null || logs.length == 0) ? null : logs.last;
</pre>
</div>
</div>
<div class="field"><h4 id="logs">
<button class="show-code">Code</button>
List&lt;<a href="../mock/LogEntry.html">LogEntry</a>&gt;         <strong>logs</strong> <a class="anchor-link"
            href="#logs"
            title="Permalink to LogEntryList.logs">#</a>
        </h4>
        <div class="doc">
<pre class="source">
logs
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="add">
<button class="show-code">Code</button>
<strong>add</strong>(<a href="../mock/LogEntry.html">LogEntry</a> entry) <a class="anchor-link" href="#add"
              title="Permalink to LogEntryList.add">#</a></h4>
<div class="doc">
<p>Add a <a class="crossref" href="../mock/LogEntry.html">LogEntry</a> to the log. </p>
<pre class="source">
add(LogEntry entry) =&gt; logs.add(entry);
</pre>
</div>
</div>
<div class="method"><h4 id="after">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>after</strong>(DateTime when, [bool inPlace = false]) <a class="anchor-link" href="#after"
              title="Permalink to LogEntryList.after">#</a></h4>
<div class="doc">
<p>Returns log events that happened after 
<span class="param">when</span>. If 
<span class="param">inPlace</span>
is true, then it returns this LogEntryList after removing
the entries that happened up to 
<span class="param">when</span>; otherwise a new
list is created.</p>
<pre class="source">
LogEntryList after(DateTime when, [bool inPlace = false]) =&gt;
   _tail((e) =&gt; e.time &gt; when, inPlace, 'after $when', logs.length);
</pre>
</div>
</div>
<div class="method"><h4 id="afterEntry">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>afterEntry</strong>(<a href="../mock/LogEntry.html">LogEntry</a> logEntry, [bool inPlace = false]) <a class="anchor-link" href="#afterEntry"
              title="Permalink to LogEntryList.afterEntry">#</a></h4>
<div class="doc">
<p>Returns log events that happened after 
<span class="param">logEntry</span>'s time.
If 
<span class="param">inPlace</span> is true, then it returns this LogEntryList after
removing the entries that happened up to <code>when</code>; otherwise a new
list is created. If 
<span class="param">logEntry</span> is null the current time is used.</p>
<pre class="source">
LogEntryList afterEntry(LogEntry logEntry, [bool inPlace = false]) =&gt;
   after(logEntry == null ? new DateTime.now() : logEntry.time);
</pre>
</div>
</div>
<div class="method"><h4 id="afterFirst">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>afterFirst</strong>(<a href="../mock/LogEntryList.html">LogEntryList</a> segment, [bool inPlace = false]) <a class="anchor-link" href="#afterFirst"
              title="Permalink to LogEntryList.afterFirst">#</a></h4>
<div class="doc">
<p>Returns log events that happened after the first event in 
<span class="param">segment</span>.
If 
<span class="param">inPlace</span> is true, then it returns this LogEntryList after removing
the entries that happened earlier; otherwise a new list is created.</p>
<pre class="source">
LogEntryList afterFirst(LogEntryList segment, [bool inPlace = false]) =&gt;
   afterEntry(segment.first, inPlace);
</pre>
</div>
</div>
<div class="method"><h4 id="afterLast">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>afterLast</strong>(<a href="../mock/LogEntryList.html">LogEntryList</a> segment, [bool inPlace = false]) <a class="anchor-link" href="#afterLast"
              title="Permalink to LogEntryList.afterLast">#</a></h4>
<div class="doc">
<p>Returns log events that happened after the last event in 
<span class="param">segment</span>.
If 
<span class="param">inPlace</span> is true, then it returns this LogEntryList after removing
the entries that happened earlier; otherwise a new list is created.</p>
<pre class="source">
LogEntryList afterLast(LogEntryList segment, [bool inPlace = false]) =&gt;
   afterEntry(segment.last, inPlace);
</pre>
</div>
</div>
<div class="method"><h4 id="before">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>before</strong>(DateTime when, [bool inPlace = false]) <a class="anchor-link" href="#before"
              title="Permalink to LogEntryList.before">#</a></h4>
<div class="doc">
<p>Returns log events that happened before 
<span class="param">when</span>. If 
<span class="param">inPlace</span>
is true, then it returns this LogEntryList after removing
the entries that happened from 
<span class="param">when</span> onwards; otherwise a new
list is created.</p>
<pre class="source">
LogEntryList before(DateTime when, [bool inPlace = false]) =&gt;
   _head((e) =&gt; e.time &gt;= when, inPlace, 'before $when', logs.length);
</pre>
</div>
</div>
<div class="method"><h4 id="beforeEntry">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>beforeEntry</strong>(<a href="../mock/LogEntry.html">LogEntry</a> logEntry, [bool inPlace = false]) <a class="anchor-link" href="#beforeEntry"
              title="Permalink to LogEntryList.beforeEntry">#</a></h4>
<div class="doc">
<p>Returns log events that happened before 
<span class="param">logEntry</span>'s time. If

<span class="param">inPlace</span> is true, then it returns this LogEntryList after removing
the entries that happened from <code>when</code> onwards; otherwise a new
list is created. If 
<span class="param">logEntry</span> is null the epoch time is used.</p>
<pre class="source">
LogEntryList beforeEntry(LogEntry logEntry, [bool inPlace = false]) =&gt;
   before(logEntry == null ?
       new DateTime.fromMillisecondsSinceEpoch(0) : logEntry.time);
</pre>
</div>
</div>
<div class="method"><h4 id="beforeFirst">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>beforeFirst</strong>(<a href="../mock/LogEntryList.html">LogEntryList</a> segment, [bool inPlace = false]) <a class="anchor-link" href="#beforeFirst"
              title="Permalink to LogEntryList.beforeFirst">#</a></h4>
<div class="doc">
<p>Returns log events that happened before the first event in 
<span class="param">segment</span>.
If 
<span class="param">inPlace</span> is true, then it returns this LogEntryList after removing
the entries that happened later; otherwise a new list is created.</p>
<pre class="source">
LogEntryList beforeFirst(LogEntryList segment, [bool inPlace = false]) =&gt;
   beforeEntry(segment.first, inPlace);
</pre>
</div>
</div>
<div class="method"><h4 id="beforeLast">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>beforeLast</strong>(<a href="../mock/LogEntryList.html">LogEntryList</a> segment, [bool inPlace = false]) <a class="anchor-link" href="#beforeLast"
              title="Permalink to LogEntryList.beforeLast">#</a></h4>
<div class="doc">
<p>Returns log events that happened before the last event in 
<span class="param">segment</span>.
If 
<span class="param">inPlace</span> is true, then it returns this LogEntryList after removing
the entries that happened later; otherwise a new list is created.</p>
<pre class="source">
LogEntryList beforeLast(LogEntryList segment, [bool inPlace = false]) =&gt;
   beforeEntry(segment.last, inPlace);
</pre>
</div>
</div>
<div class="method"><h4 id="findLogEntry">
<button class="show-code">Code</button>
int <strong>findLogEntry</strong>(logFilter, [int start = 0, int failureReturnValue = -1, skip = 1]) <a class="anchor-link" href="#findLogEntry"
              title="Permalink to LogEntryList.findLogEntry">#</a></h4>
<div class="doc">
<p> Find the first log entry that satisfies 
<span class="param">logFilter</span> and
 return its position. A search 
<span class="param">start</span> position can be provided
 to allow for repeated searches. 
<span class="param">logFilter</span> can be a <a class="crossref" href="../mock/CallMatcher.html">CallMatcher</a>,
 or a predicate function that takes a <a class="crossref" href="../mock/LogEntry.html">LogEntry</a> argument and returns
 a bool. If 
<span class="param">logFilter</span> is null, it will match any <a class="crossref" href="../mock/LogEntry.html">LogEntry</a>.
 If no entry is found, then 
<span class="param">failureReturnValue</span> is returned.
 After each check the position is updated by 
<span class="param">skip</span>, so using
 
<span class="param">skip</span> of -1 allows backward searches, using a 
<span class="param">skip</span> of 2 can
 be used to check pairs of adjacent entries, and so on.</p>
<pre class="source">
int findLogEntry(logFilter, [int start = 0, int failureReturnValue = -1,
   skip = 1]) {
 logFilter = _makePredicate(logFilter);
 int pos = start;
 while (pos &gt;= 0 &amp;&amp; pos &lt; logs.length) {
   if (logFilter(logs[pos])) {
     return pos;
   }
   pos += skip;
 }
 return failureReturnValue;
}
</pre>
</div>
</div>
<div class="method"><h4 id="following">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>following</strong>(<a href="../mock/LogEntryList.html">LogEntryList</a> keys, {mockNameFilter: null, logFilter: null, int distance: 1, bool includeKeys: false}) <a class="anchor-link" href="#following"
              title="Permalink to LogEntryList.following">#</a></h4>
<div class="doc">
<p>Iterate through the LogEntryList looking for matches to the entries
in 
<span class="param">keys</span>; for each match found the closest 
<span class="param">distance</span> subsequent log
entries that match <code>mocknameFilter</code> and 
<span class="param">logFilter</span> will be included in
the result. If 
<span class="param">includeKeys</span> is true then the entries in 
<span class="param">keys</span> that
resulted in entries in the output list are themselves included in the
output list. If 
<span class="param">distance</span> is zero then all matches are included.
See <a class="crossref" href="../mock/LogEntryList.html#preceding">preceding</a> for a usage example.</p>
<pre class="source">
LogEntryList following(LogEntryList keys,
                      {mockNameFilter: null,
                      logFilter: null,
                      int distance: 1,
                      bool includeKeys: false}) =&gt;
   _neighboring(false, keys, mockNameFilter, logFilter,
       distance, includeKeys);
</pre>
</div>
</div>
<div class="method"><h4 id="from">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>from</strong>(DateTime when, [bool inPlace = false]) <a class="anchor-link" href="#from"
              title="Permalink to LogEntryList.from">#</a></h4>
<div class="doc">
<p>Returns log events that happened from 
<span class="param">when</span> onwards. If

<span class="param">inPlace</span> is true, then it returns this LogEntryList after
removing the entries that happened before 
<span class="param">when</span>; otherwise
a new list is created.</p>
<pre class="source">
LogEntryList from(DateTime when, [bool inPlace = false]) =&gt;
   _tail((e) =&gt; e.time &gt;= when, inPlace, 'from $when', logs.length);
</pre>
</div>
</div>
<div class="method"><h4 id="fromEntry">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>fromEntry</strong>(<a href="../mock/LogEntry.html">LogEntry</a> logEntry, [bool inPlace = false]) <a class="anchor-link" href="#fromEntry"
              title="Permalink to LogEntryList.fromEntry">#</a></h4>
<div class="doc">
<p>Returns log events that happened from 
<span class="param">logEntry</span>'s time onwards.
If 
<span class="param">inPlace</span> is true, then it returns this LogEntryList after
removing the entries that happened before <code>when</code>; otherwise
a new list is created. If 
<span class="param">logEntry</span> is null the current time is used.</p>
<pre class="source">
LogEntryList fromEntry(LogEntry logEntry, [bool inPlace = false]) =&gt;
   from(logEntry == null ? new DateTime.now() : logEntry.time);
</pre>
</div>
</div>
<div class="method"><h4 id="fromFirst">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>fromFirst</strong>(<a href="../mock/LogEntryList.html">LogEntryList</a> segment, [bool inPlace = false]) <a class="anchor-link" href="#fromFirst"
              title="Permalink to LogEntryList.fromFirst">#</a></h4>
<div class="doc">
<p>Returns log events that happened from the time of the first event in

<span class="param">segment</span> onwards. If 
<span class="param">inPlace</span> is true, then it returns this
LogEntryList after removing the earlier entries; otherwise a new list
is created.</p>
<pre class="source">
LogEntryList fromFirst(LogEntryList segment, [bool inPlace = false]) =&gt;
   fromEntry(segment.first, inPlace);
</pre>
</div>
</div>
<div class="method"><h4 id="fromLast">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>fromLast</strong>(<a href="../mock/LogEntryList.html">LogEntryList</a> segment, [bool inPlace = false]) <a class="anchor-link" href="#fromLast"
              title="Permalink to LogEntryList.fromLast">#</a></h4>
<div class="doc">
<p>Returns log events that happened from the time of the last event in

<span class="param">segment</span> onwards. If 
<span class="param">inPlace</span> is true, then it returns this
LogEntryList after removing the earlier entries; otherwise a new list
is created.</p>
<pre class="source">
LogEntryList fromLast(LogEntryList segment, [bool inPlace = false]) =&gt;
   fromEntry(segment.last, inPlace);
</pre>
</div>
</div>
<div class="method"><h4 id="getMatches">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>getMatches</strong>([mockNameFilter, logFilter, <a href="../matcher/Matcher.html">Matcher</a> actionMatcher, bool destructive = false]) <a class="anchor-link" href="#getMatches"
              title="Permalink to LogEntryList.getMatches">#</a></h4>
<div class="doc">
<p>Create a new <a class="crossref" href="../mock/LogEntryList.html#LogEntryList">LogEntryList</a> consisting of <a class="crossref" href="../mock/LogEntry.html">LogEntry</a>s from
this list that match the specified 
<span class="param">mockNameFilter</span> and 
<span class="param">logFilter</span>.

<span class="param">mockNameFilter</span> can be null, a <code>String</code>, a predicate <code>Function</code>,
or a <code>Matcher</code>. If 
<span class="param">mockNameFilter</span> is null, this is the same as
<code>anything</code>.
If 
<span class="param">logFilter</span> is null, all entries in the log will be returned.
Otherwise 
<span class="param">logFilter</span> should be a <a class="crossref" href="../mock/CallMatcher.html">CallMatcher</a> or  predicate function
that takes a <a class="crossref" href="../mock/LogEntry.html">LogEntry</a> and returns a bool.
If 
<span class="param">destructive</span> is true, the log entries are removed from the
original list.</p>
<pre class="source">
LogEntryList getMatches([mockNameFilter,
                       logFilter,
                       Matcher actionMatcher,
                       bool destructive = false]) {
 if (mockNameFilter == null) {
   mockNameFilter = anything;
 } else {
   mockNameFilter = wrapMatcher(mockNameFilter);
 }
 Function entryFilter = _makePredicate(logFilter);
 String filterName = _qualifiedName(mockNameFilter, logFilter.toString());
 LogEntryList rtn = new LogEntryList(filterName);
 MatchState matchState = new MatchState();
 for (var i = 0; i &lt; logs.length; i++) {
   LogEntry entry = logs[i];
   if (mockNameFilter.matches(entry.mockName, matchState) &amp;&amp;
       entryFilter(entry)) {
     if (actionMatcher == null ||
         actionMatcher.matches(entry, matchState)) {
       rtn.add(entry);
       if (destructive) {
         logs.removeRange(i--, 1);
       }
     }
   }
 }
 return rtn;
}
</pre>
</div>
</div>
<div class="method"><h4 id="preceding">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>preceding</strong>(<a href="../mock/LogEntryList.html">LogEntryList</a> keys, {mockNameFilter: null, logFilter: null, int distance: 1, bool includeKeys: false}) <a class="anchor-link" href="#preceding"
              title="Permalink to LogEntryList.preceding">#</a></h4>
<div class="doc">
<p>Iterate through the LogEntryList looking for matches to the entries
in 
<span class="param">keys</span>; for each match found the closest 
<span class="param">distance</span> prior log entries
that match <code>mocknameFilter</code> and 
<span class="param">logFilter</span> will be included in the result.
If 
<span class="param">includeKeys</span> is true then the entries in 
<span class="param">keys</span> that resulted in
entries in the output list are themselves included in the output list. If

<span class="param">distance</span> is zero then all matches are included.</p>
<p>The idea here is that you could find log entries that are related to
other logs entries in some temporal sense. For example, say we have a
method commit() that returns -1 on failure. Before commit() gets called
the value being committed is created by process(). We may want to find
the calls to process() that preceded calls to commit() that failed.
We could do this with:</p>
<pre> <span class="i ">print</span><span class="p ">(</span><span class="i ">log</span><span class="p ">.</span><span class="i ">preceding</span><span class="p ">(</span><span class="i ">log</span><span class="p ">.</span><span class="i ">getLogs</span><span class="p ">(</span><span class="i ">callsTo</span><span class="p ">(</span><span class="s si">'commit'</span><span class="p ">)</span><span class="p ">,</span> <span class="i ">returning</span><span class="p ">(</span><span class="o ">-</span><span class="n ">1</span><span class="p ">)</span><span class="p ">)</span><span class="p ">,</span>
     <span class="i ">logFilter</span><span class="p ">:</span> <span class="i ">callsTo</span><span class="p ">(</span><span class="s si">'process'</span><span class="p ">)</span><span class="p ">)</span><span class="p ">.</span><span class="i ">toString</span><span class="p ">(</span><span class="p ">)</span><span class="p ">)</span><span class="p ">;</span></pre>
<p>We might want to include the details of the failing calls to commit()
to see what parameters were passed in, in which case we would set

<span class="param">includeKeys</span>.</p>
<p>As another simple example, say we wanted to know the three method
calls that immediately preceded each failing call to commit():</p>
<pre><span class="i ">print</span><span class="p ">(</span><span class="i ">log</span><span class="p ">.</span><span class="i ">preceding</span><span class="p ">(</span><span class="i ">log</span><span class="p ">.</span><span class="i ">getLogs</span><span class="p ">(</span><span class="i ">callsTo</span><span class="p ">(</span><span class="s si">'commit'</span><span class="p ">)</span><span class="p ">,</span> <span class="i ">returning</span><span class="p ">(</span><span class="o ">-</span><span class="n ">1</span><span class="p ">)</span><span class="p ">)</span><span class="p ">,</span>
    <span class="i ">distance</span><span class="p ">:</span> <span class="n ">3</span><span class="p ">)</span><span class="p ">.</span><span class="i ">toString</span><span class="p ">(</span><span class="p ">)</span><span class="p ">)</span><span class="p ">;</span></pre>
<pre class="source">
LogEntryList preceding(LogEntryList keys,
                      {mockNameFilter: null,
                      logFilter: null,
                      int distance: 1,
                      bool includeKeys: false}) =&gt;
   _neighboring(true, keys, mockNameFilter, logFilter,
       distance, includeKeys);
</pre>
</div>
</div>
<div class="method"><h4 id="stepwiseValidate">
<button class="show-code">Code</button>
bool <strong>stepwiseValidate</strong>(<a href="../mock/StepValidator.html">StepValidator</a> validator, [String reason = '']) <a class="anchor-link" href="#stepwiseValidate"
              title="Permalink to LogEntryList.stepwiseValidate">#</a></h4>
<div class="doc">
<p>Iterate through the list and call the 
<span class="param">validator</span> function with the
log <code>List</code> and position. The 
<span class="param">validator</span> should return the number of
positions to advance upon success, or zero upon failure. When zero is
returned an error is reported. 
<span class="param">reason</span> can be used to provide a
more descriptive failure message. If a failure occurred false will be
returned (unless the failure handler itself threw an exception);
otherwise true is returned.
The use case here is to perform more complex validations; for example
we may want to assert that the return value from some function is
later used as a parameter to a following function. If we filter the logs
to include just these two functions we can write a simple validator to
do this check.</p>
<pre class="source">
bool stepwiseValidate(StepValidator validator, [String reason = '']) {
 if (_mockFailureHandler == null) {
   _mockFailureHandler =
       new _MockFailureHandler(getOrCreateExpectFailureHandler());
 }
 var i = 0;
 while (i &lt; logs.length) {
   var n = validator(logs, i);
   if (n == 0) {
     if (reason.length &gt; 0) {
       reason = ': $reason';
     }
     _mockFailureHandler.fail("Stepwise validation failed at $filter "
                              "position $i$reason");
     return false;
   } else {
     i += n;
   }
 }
 return true;
}
</pre>
</div>
</div>
<div class="method"><h4 id="toString">
<button class="show-code">Code</button>
String <strong>toString</strong>([DateTime baseTime]) <a class="anchor-link" href="#toString"
              title="Permalink to LogEntryList.toString">#</a></h4>
<div class="doc">
<p>Turn the logs into human-readable text. If 
<span class="param">baseTime</span> is specified
then each entry is prefixed with the offset from that time in
milliseconds; otherwise the time of day is used.</p>
<pre class="source">
String toString([DateTime baseTime]) {
 String s = '';
 for (var e in logs) {
   s = '$s${e.toString(baseTime)}\n';
 }
 return s;
}
</pre>
</div>
</div>
<div class="method"><h4 id="until">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>until</strong>(DateTime when, [bool inPlace = false]) <a class="anchor-link" href="#until"
              title="Permalink to LogEntryList.until">#</a></h4>
<div class="doc">
<p>Returns log events that happened until 
<span class="param">when</span>. If 
<span class="param">inPlace</span>
is true, then it returns this LogEntryList after removing
the entries that happened after 
<span class="param">when</span>; otherwise a new
list is created.</p>
<pre class="source">
LogEntryList until(DateTime when, [bool inPlace = false]) =&gt;
   _head((e) =&gt; e.time &gt; when, inPlace, 'until $when', logs.length);
</pre>
</div>
</div>
<div class="method"><h4 id="untilEntry">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>untilEntry</strong>(<a href="../mock/LogEntry.html">LogEntry</a> logEntry, [bool inPlace = false]) <a class="anchor-link" href="#untilEntry"
              title="Permalink to LogEntryList.untilEntry">#</a></h4>
<div class="doc">
<p>Returns log events that happened until 
<span class="param">logEntry</span>'s time. If

<span class="param">inPlace</span> is true, then it returns this LogEntryList after removing
the entries that happened after <code>when</code>; otherwise a new
list is created. If 
<span class="param">logEntry</span> is null the epoch time is used.</p>
<pre class="source">
LogEntryList untilEntry(LogEntry logEntry, [bool inPlace = false]) =&gt;
   until(logEntry == null ?
       new DateTime.fromMillisecondsSinceEpoch(0) : logEntry.time);
</pre>
</div>
</div>
<div class="method"><h4 id="untilFirst">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>untilFirst</strong>(<a href="../mock/LogEntryList.html">LogEntryList</a> segment, [bool inPlace = false]) <a class="anchor-link" href="#untilFirst"
              title="Permalink to LogEntryList.untilFirst">#</a></h4>
<div class="doc">
<p>Returns log events that happened until the first event in 
<span class="param">segment</span>.
If 
<span class="param">inPlace</span> is true, then it returns this LogEntryList after removing
the entries that happened later; otherwise a new list is created.</p>
<pre class="source">
LogEntryList untilFirst(LogEntryList segment, [bool inPlace = false]) =&gt;
   untilEntry(segment.first, inPlace);
</pre>
</div>
</div>
<div class="method"><h4 id="untilLast">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>untilLast</strong>(<a href="../mock/LogEntryList.html">LogEntryList</a> segment, [bool inPlace = false]) <a class="anchor-link" href="#untilLast"
              title="Permalink to LogEntryList.untilLast">#</a></h4>
<div class="doc">
<p>Returns log events that happened until the last event in 
<span class="param">segment</span>.
If 
<span class="param">inPlace</span> is true, then it returns this LogEntryList after removing
the entries that happened later; otherwise a new list is created.</p>
<pre class="source">
LogEntryList untilLast(LogEntryList segment, [bool inPlace = false]) =&gt;
   untilEntry(segment.last, inPlace);
</pre>
</div>
</div>
<div class="method"><h4 id="verify">
<button class="show-code">Code</button>
<a href="../mock/LogEntryList.html">LogEntryList</a> <strong>verify</strong>(<a href="../matcher/Matcher.html">Matcher</a> matcher) <a class="anchor-link" href="#verify"
              title="Permalink to LogEntryList.verify">#</a></h4>
<div class="doc">
<p>Apply a unit test <code>Matcher</code> to the <a class="crossref" href="../mock/LogEntryList.html#LogEntryList">LogEntryList</a>. </p>
<pre class="source">
LogEntryList verify(Matcher matcher) {
 if (_mockFailureHandler == null) {
   _mockFailureHandler =
       new _MockFailureHandler(getOrCreateExpectFailureHandler());
 }
 expect(logs, matcher, reason:filter, failureHandler: _mockFailureHandler);
 return this;
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
